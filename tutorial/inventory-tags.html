<html>
<head>
<title>Inventory Tags for Source</title>
</head>
<body>

<a name="Inventory_Tags_for_Source"></a>

<a href="http://www.regexps.com">The Hackerlab at <code>regexps.com</code></a>

<h2 align=center>Inventory Tags for Source</h2>




<small>
<b>up: </b><a href="arch.html#arch_Meets_hello-world">arch Meets hello-world</a></br>
<b>next: </b><a href="importing-first.html#Importing_the_First_Revision">Importing the First Revision</a></br>

<b>prev: </b><a href="inventories.html#Project_Tree_Inventories">Project Tree Inventories</a></br>

</small>
<br>






<p><strong><u>Caution: Steep Learning Curve:</u></strong> As in the previous chapter, the
concepts and commands introduced here are likely to be unfamiliar to
you, even if you have used other revision control systems.   Once 
you &quot;get it&quot;, though, this will seem quite natural.  Best of all,
this is the last tricky step before we can start storing project trees
in an archive.
</p>
<a name="Two_Names_for_Every_File"></a>



<h3 align=center>Two Names for Every File</h3>










<p>In the <code>arch</code>
 world, every source file (and directory) in your project
tree has two names: a <em>
<a name="index-pt:0"></a>

file path
</em>
 and a <em>
<a name="index-pt:1"></a>

inventory tag
</em>
.
</p><p>The <strong>file path</strong> of a file always begins with the string <code>./</code>
 and
continues with a relative path name.  It describes <em>where</em> within a
source tree a file is located.
</p><p>The <strong>inventory tag</strong> of a file is a (mostly) arbitrary string that is
unique to the file within the tree.
</p><p>Ordinarily, when a file is moved, its file path changes, but its
inventory tag remains the same.
</p><p>For example, let's suppose that we have a tree with the files:
</p><pre>

        file path               inventory tag
        ---------               -------------

        ./hw.c                  i_tag_hw
        ./main.c                i_tag_main


</pre>
<p>but then we rename <code>hw.c</code>
 to <code>hello.c</code>
.   Afterwards, we'll have:
</p><pre>
        file path               inventory tag
        ---------               -------------

        ./hello.c               i_tag_hw
        ./main.c                i_tag_main


</pre>
<p>This chapter will teach you how tags are assigned to files, how
tags are managed, and how they are used by <code>arch</code>
.
</p>











<a name="Why_is_it_Like_This_--_The_Purpose_of_Inventory_Tags"></a>



<h3 align=center>Why is it Like This -- The Purpose of Inventory Tags</h3>










<p>As you'll see in later chapters, <code>arch</code>
 is good at managing <em>changes</em>
made to source trees and the files they contain, and good at telling
you about the <em>history</em> of trees and files.
</p><p>As an example, let's suppose that Alice and Bob are both working on
the <code>hello_world</code>
 project.  In her tree, Alice makes some changes to
<code>hw.c</code>
.  In his tree, Bob renames <code>hw.c</code>
 to <code>hello.c</code>
.
</p><p>At some point it is necessary to &quot;sync-up&quot; Alice and Bob.  Bob
should wind up with the changes Alice has been making.   Alice should
wind up with the same file renaming that Bob has done.
</p><p><code>arch</code>
 provides many mechanisms for that syncing up -- it's one of the
most important things that <code>arch</code>
 can do -- but nearly all of them
boil down to computing and applying <strong>changesets</strong>.
</p><p>Alice can ask <code>arch</code>
 to create a changeset describing the work she's
done, and that changeset will describe the changes she made within
<code>hw.c</code>
.  Bob can create a changeset and that changeset will describe
the file renaming he did.
</p><p>If Alice applies Bob's changeset to her tree, her copy of <code>hw.c</code>

should be renamed <code>hello.c</code>
.   But a trickier case is this:  What
happens if Bob applies Alice's changeset to his tree?
</p><p>Alice changed a file named <code>./hw.c</code>
, but in Bob's tree, those same
changes should be made to a file named <code>./hello.c</code>
.  Fortunately, both
files have the same inventory tag:
</p><pre>

        file path               inventory tag
        ---------               -------------

                 Alice's tree:
        ./hw.c                  i_tag_hw

                 Bob's tree:
        ./hello.c               i_tag_hw


</pre>
<p>In Alice's changeset, the changes Alice made are described as being
made to the file whose tag is <code>i_tag_hw</code>
.
</p><p>Therefore, when applying that changeset to Bob's tree, <code>arch</code>
 knows to
apply the changes to the file with that same tag;  it knows to apply
the changes to his <code>./hello.c</code>
.
</p><p>That example illustrates what inventory tags are for: they allow
<code>arch</code>
 to describe the changes made to a tree in terms of the logical
identity of files rather than their physical location.  There are many
more complicated examples of how inventory tags come into play, but
now you've seen at least the basic point.
</p>











<a name="Choices_about_Tags_--_Introducing_tagging-method"></a>



<h3 align=center>Choices about Tags -- Introducing tagging-method</h3>










<p>So, how are files given inventory tags?  Filesystems do not, as a
general rule, have any such concept as inventory tags built-in.
Operating systems don't have inventory tags built-in.  Rather, users
have to take explicit action to assign tags to files and to maintain
that assignment.
</p><p><code>arch</code>
 gives you a choice.  There are three possible ways you can
assign tags to files.   When you first create a project, you choose
from one of these three techniques.
</p><p>The possibilities are briefly introduced here, then in more detail
below.
</p><p><strong><u>The names Method of Tagging</u></strong> You <em>are</em> free to just ignore tags -- to
not use them at all.  This is called the <code>names</code>
 method of tagging.
In this method, the inventory tag of every file is essentially the
same as the file path of that file.  As a result, if you rename a
file, its tag changes:
</p><pre>

           The names Method of Tagging


        file path               inventory tag
        ---------               -------------

                Before a rename
        ./hw.c                  ?./hw.c

                 After a rename

        ./hello.c               ?./hello.c


</pre>
<p>If you don't care about synchronizing changes between trees in which
files have been renamed, the <code>names</code>
 method is the easiest to use.
</p><p><strong><u>The explicit Method of Tagging</u></strong> In the <code>explicit</code>
 method, inventory
tags are stored <em>separately</em> from files, in subdirectories called
<code>.arch-ids</code>
.  Using this method most resembles using older revision
control systems such as <code>CVS</code>
: if you add a new source file, you must
use the command <code>tla add</code>
 to assign it a tag; if you remove a file,
you must use <code>tla delete</code>
 to remove its tag; if you rename a file,
you must use <code>tla move</code>
 to move the corresponding tag file.  This is
a tried-and-true technique, but some users find the necessity of
issuing commands like <code>add</code>
, <code>delete</code>
, and <code>move</code>
 to be inconvenient.
</p><p><strong><u>The tagline Method of Tagging</u></strong> The <code>tagline</code>
 method is a superset
of both the <code>explicit</code>
 method and the <code>names</code>
 method.  You <em>may</em>, for
a particular file, define no tag -- in which case it works like the
<code>names</code>
 method.  You <em>may</em> define a tag using <code>tla add</code>
 -- in which
case it works like the <code>explicit</code>
 method.  However, the real
<em>convenience</em> of the <code>tagline</code>
 method comes from this: you <em>may</em>
define the tag for a file by adding a specially formatted string near
the top or bottom of that file (e.g., in a comment for source files).
</p><p>I strongly recommend the <code>tagline</code>
 method, even though it is the
least familiar to new users.   As you'll see below, its convenience
far outweighs its drawbacks.
</p>











<a name="Setting_the_Tagging_Method"></a>



<h3 align=center>Setting the Tagging Method</h3>










<p>To set or check the tagging method for a tree, use the
<code>tagging-method</code>
 command:
</p><pre>
        % cd ~/wd/hello-world

        # set the tagging method
        # 
        % tla tagging-method tagline


        # check the tagging method
        # 
        % tla tagging-method
        tagline


</pre>
<p>Possible values when setting a tagging method are <code>names</code>
, <code>explicit</code>
,
and <code>tagline</code>
.  (A now deprecated but still supported method called
<code>implicit</code>
, which is similar to <code>tagline</code>
, is also permitted.)
</p>











<a name="Using_the_names_Tagging_Method"></a>



<h3 align=center>Using the names Tagging Method </h3>










<p><a name="index-pt:2"></a>

</p><p>If you want to use the <code>names</code>
 method of tagging, use this command:
</p><pre>
        % tla tagging-method names

</pre>
<p>Thereafter, every file will have a tag that is derived from its path
relative to the tree root.
</p><p>(Again, the <code>names</code>
 tagging method has the disadvantage that
changesets do not work cleanly if files have been renamed.)
</p>











<a name="Using_the_explicit_Tagging_Method"></a>



<h3 align=center>Using the explicit Tagging Method</h3>










<p><a name="index-pt:3"></a>

<a name="index-pt:4"></a>

<a name="index-pt:5"></a>

<a name="index-pt:6"></a>

</p><p>If you want to use the <code>explicit</code>
 method of tagging, use this command:
</p><pre>
        % tla tagging-method explicit

</pre>
<p>When using the <code>explicit</code>
 method, it is (ordinarily) necessary to 
use <code>tla add</code>
 to tag every file and directory:
</p><pre>
        % tla add FILE

</pre>
<p>If <code>FILE</code>
 is a directory, that will create <code>FILE/.arch_ids/=id</code>
.  If
it is a regular file or symbolic link, it will create (in the same
directory) <code>.arch_ids/FILE.id</code>
.  In either case, the file created will
contain an automatically generated tag for the file.
</p><p>If you remove a regular file or symbolic link, you must use the
command:
</p><pre>
        % tla delete FILE

</pre>
<p>That won't remove <code>FILE</code>
 itself, but it will remove the inventory tag
for <code>FILE</code>
.
</p><p>In order to remove a directory, you must yourself remove the
<code>.arch_ids</code>
 subdirectory.  That will also implicitly remove the
inventory tags of any files that <code>arch</code>
 thinks are stored in that
directory.  (For example, using <code>rm -rf</code>
 to remove a directory also
removes its tag.)
</p><p>If you rename a regular file or symbolic link, you can use the
command:
</p><pre>
        % tla move OLD-NAME NEW-NAME

</pre>
<p>to move the inventory tag for that file.
</p><p><strong><u>Usage Note:</u></strong> <code>tla move</code>
 does not work like the unix command <code>mv</code>
.
In particular, <code>NEW-NAME</code>
 must be the new name of the file -- not the
name of a directory into which the file is being moved.
</p><p>If you rename a directory, its inventory tag (and the tags for all
files and subdirectories it contains) move with it automatically
(because the <code>.arch_ids</code>
 subdirectory has moved).
</p><p>When you run <code>tla inventory</code>
 in a working directory using explicit
tagging, only explicitly designated source files are listed. 
If you would rather see a list of all files passing the naming
conventions for source files, use:
</p><pre>
        % tla inventory --source --names

</pre>
<p>You should also read about <code>tree-lint</code>
 (see <a href="inventory-tags.html#Keeping_Things_Neat_and_Tidy">Keeping Things Neat and Tidy</a>).
</p>











<a name="Using_a_tagline_Inventory"></a>



<h3 align=center>Using a tagline Inventory</h3>










<p><a name="index-pt:7"></a>

</p><p>To use tagline tagging, use the following command in your project
tree:
</p><pre>
        % tla tagging-method tagline

</pre>
<p>With this method: any file with <em>no</em> tag is assigned a tag based on
its location -- just as in the <code>names</code>
 method.  Any file assigned a
tag with <code>tla add</code>
 uses that tag -- just as in the <code>explicit</code>

method.  Finally, though, you can tag a file by adding a specially
formatted string near the top or bottom of the file.
</p><p>A tag within a file is a single line that occurs within <code>1024</code>
 bytes of
the start or end of the file and has the form:
</p><pre>
        &lt;punct>arch-tag:&lt;spaces>&lt;tag>

</pre>
<p>For example:
</p><pre>

        /* arch-tag: `main' for the hello world program
         */


</pre>
<p><strong><u>Note:</u></strong> Leading and trailing spaces around an inventory tag are not
considered part of the tag.  Within a tag, every non-graphical
character is replaced by <code>_</code>
.  For example, you write the that tag:
</p><pre>
        `main' for the hello    world program

</pre>
<p>the actual inventory tag is:
</p><pre>
        `main'_for_the_hello____world_program

</pre>












<a name="Keeping_Things_Neat_and_Tidy"></a>



<h3 align=center>Keeping Things Neat and Tidy</h3>










<p><a name="index-pt:8"></a>

</p><p>The command:
</p><pre>
        % tla tree-lint

</pre>
<p>is useful for keeping things neat and tidy.
</p><p>If you use <code>explicit</code>
 tagging, it will tell you of any tags for which
the corresponding file does not exist.  It will tell you of any files
that pass the naming conventions, but for which no explicit tag
exists.
</p><p>If you use <code>tagline</code>
 tagging, it will tell you of any files for which
no tag can be found -- either explicit or tagline.  It will tell you
of any explicit tags for which the corresponding file does not exist.
</p><p>In either case, or if you are using the <code>names</code>
 tagging method,
<code>tree-lint</code>
 will tell you of any files that don't fit the naming
conventions at all.
</p><p>Finally, if you use explicit or tagline tagging, <code>tree-lint</code>
 will
check for cases where multiple files use the same tag.  If any two
files do have the same tag, you <strong>must</strong> correct that, either by
editing the tag (if it is in the file itself) or by using <code>delete</code>

and <code>add</code>
 to replace a duplicated explicit tag.
</p>











<a name="Tagging_the_hello-world_Project"></a>



<h3 align=center>Tagging the hello-world Project</h3>










<p>To continue the example started in earlier chapters: let's use the
<code>tagline</code>
 tagging method for the <code>hello-world</code>
 project:
</p><pre>
        % cd ~/wd/hello-world

        % tla tagging-method tagline

</pre>
<p>So, what does <code>tree-lint</code>
 tell us?
</p><pre>
        % tla tree-lint
        These apparent source files lack inventory tags:
 
        ./hw.c
        ./main.c



</pre>
<p>If we edit the source files to add tags:
</p><pre>
        % tail -3 main.c
        
        /* arch-tag: main module of the hello-world project
         */
        % tail -3 hw.c
        
        /* arch-tag: hello_world module of the hello-world project
         */

</pre>
<p>Then the next run of <code>tree-lint</code>
 omits the warning.
</p><p><strong><u>Usage Note 1:</u></strong> Notice that we didn't tag any of the files in <code>{arch}</code>
.
<code>arch</code>
 implicitly provides tags for all of its control files.
</p><p><strong><u>Usage Note 2:</u></strong> Our little sample project doesn't have any
subdirectories other than <code>arch</code>
 control directories.  If it did, we
might want to tag those with <code>tla add</code>
.
</p>











<a name="Other_Ways_to_Tag_Files"></a>



<h3 align=center>Other Ways to Tag Files</h3>










<p><a name="index-pt:9"></a>

</p><p>In some situations, it isn't convenient to explicitly tag every file
or to add a tagline tag to every file.
</p><p>You can supply a <em>
<a name="index-pt:10"></a>

default tag
</em>
 for every file in a directory that
doesn't have an explicit tag with the command:
</p><pre>
        % tla explicit-default TAG-PREFIX

</pre>
<p>After that, every file in that directory which lacks an explicit tag
will have the tag:
</p><pre>
        TAG-PREFIX__BASENAME

</pre>
<p>where <code>BASENAME</code>
 is the basename of the file.  Default tags created in
this way take precedence over tagline tags embedded in files.  You
can find out the default tag for a directory with:
</p><pre>
        % tla explicit-default
        TAG-PREFIX

</pre>
<p>and remove the default with:
</p><pre>
        % tla explicit-default --delete

</pre>
<p>You can also specify a default tag which has <em>lower</em> precedence than
tagline tags:
</p><pre>
        % tla explicit-default --weak TAG-PREFIX

</pre>
<p>and view that default:
</p><pre>
        % tla explicit-default --weak

</pre>
<p>or delete it:
</p><pre>
        % tla explicit-default --weak --delete

</pre>












<a name="Telling_tree-lint_to_Shut_Up"></a>



<h3 align=center>Telling tree-lint to Shut Up</h3>










<p><a name="index-pt:11"></a>

<a name="index-pt:12"></a>

</p><p>When using tagline tags, you may sometimes have a directory with many
files that have no tag (either explicit or tagline), but not want
those files to appear in a report of untagged files generated by
<code>tree-lint</code>
.  There are two ways to tell <code>tree-lint</code>
 to shut-up
about such files:
</p><p>One is to provide a default explicit tag or weak default explicit tag
using <code>tla explicit-default</code>
, as described above.  
</p><p>The second method is to label the directory as a &quot;don't care&quot;
directory -- which means that <code>tree-lint</code>
 shouldn't complain about
untagged files.  You can do that with:
</p><pre>
        % tla explicit-default --dont-care set

</pre>
<p>or remove the &quot;don't care&quot; flag with:
</p><pre>
        % tla explicit-default --delete --dont-care

</pre>
<p>You can find out whether the &quot;don't care&quot; flag is set in a given
directory with:
</p><pre>
        % tla explicit-default --dont-care

</pre>



















<small><i>arch Meets hello-world: A Tutorial Introduction to The arch Revision Control System

</i></small><br>


<a href="http://www.regexps.com">The Hackerlab at <code>regexps.com</code></a>

</body>
